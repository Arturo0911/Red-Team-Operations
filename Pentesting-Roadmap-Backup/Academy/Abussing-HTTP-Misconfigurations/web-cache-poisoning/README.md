# Abussing HTTP misconfigurations.

Web cache poisoning is an advanced attack vector that forces a web cahce to serve
malicious content to unuespecting usres wivistin the vulnerable site. Web caches are
often used in the deploytment of web applications for performance reaons as they
reduce the load on the web server. By exploiting web cache poisoning, an attacker may
be able to deliver malicious content to a vast number of users. Web cache poisoning
can also be used to increase the severity of vulnerabilities in the web application. For 
instance, it can be used to deliver reflected XSS payload to all users that visita the
website, thus eliminating the need for user interaction which is usually required for 
exploiting reflected XSS vulnerabilities.


### Commonly used web caches include:
Apahce, Nginx, and Squid


## Inner Working sof Web Caches

### Benefits of Caching
When providing a web service that is used by a large number of users, scalability is
ipmortant. The more users use the service, the more load is genraeted on the web
server. To reduce the web server load and distribute users between redundant web
servers, Content Delivery Networks (CDNs) and reverse proxies can be used.


## How do web Caches work?

Ad discussed above, web cahces store resources to reduce the load on the web server.
These can be static resources such a stylesheets or script files. but also dynamic
responses generated by the web server based on user-supplied data such as search
queries. To serve cached resources, the web cache need to be able to distinguish
between requests to determine whether two requests can be served the same cached
response, or if a fresh response needds to be fetched from the web server


Just comparing requests byte-by-byte to determine whether thet should be served the
same response is highly inefficient, as different browsers send different headeres that do
not directly influence the response, for instance, the User-Agent header. Furthermore,
web browsers commonly populate the referer header to inform the web server from
where a resource has been requested, ghowerver, in most cases, this does also not directly influence the response.


To circumvent these issues, web caches only use a subset of all request paramters to
determine whether two requests shouled be served the same response. This subset is
called Cache Key. In most default configurations. this includes the request path, the
GET paramters, and the Host header, However, cache keys can be configured individually to include or exclude any HTTP parametes or headers, to work optimally for a specific web application.

Let's have a llok at an example. Assuming the web cache is configured to use the
default configuration of request path. GET paramters, and host header as the cache
key, the following two requests would be served the same response.


#### First request
```http
GET /index.html?language=en HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.125 Safari/537.36
Accept: text/html
```


The sencond request has the same cache key and this gets served the same response.
The requests differ in the User-Agent header due to different operationg systems and
contain a different Accept header as well.

#### Sencond request

```http
GET /index.html?language=en HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 13_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15
Accept: text/html,application/xhtml+xml,application/xml
```

Nginx configuration

```nginx
http {
  proxy_cache_path /cache levels=1:2 keys_zone=STATIC:10m inactive=24h max_size=1g;

  server {
    listen       80;

    location / {
      proxy_pass             http://172.17.0.1:80;
      proxy_buffering        on;
      proxy_cache            STATIC;
      proxy_cache_valid      2m;
      proxy_cache_key $scheme$proxy_host$uri$args;
      add_header X-Cache-Status $upstream_cache_status;
    }
  }
}
```
Description of all elements:

    - proxy_cache_path: sets general parameters of the cache like the storage location
    - proxy_pass: sets the location of the web server.
    - proxy_buffering: enables caching.
    - proxy_cache: sets the name of the cache (as defined in proxy_cache_path)
    - proxy_cache_valid: sets the time after which the cache expires
    - proxy_cache_key: defines the cache key
    - add_headers: adds the X-cache-Status headers to responses to indicate whether the response was cached.



For the solution of the first challenge:

first at all, I have to check using the respective documentation, which parameter 
in the HEAD GET method it's the Unkeyed parameter to be cached

Checking the page, we can see

```
http://138.68.164.196:31813/index.php?language=en
```

so using the form to send information, we can see the parameter content it's added into the URL body
and after that we can send XSS to get the flag, giving the case, the url http://138.68.164.196:31813/admin.php?reveal_flag=1
it's blocked because we're not the fucking admin ;(


So for that reason, we use the following url to send the payload to be cached, notice the parameter set in the language,
should be different from the original language=en, in this case we use:

"http://138.68.164.196:31813/index.php?content=%22%3e%3cscript%3evar%20xhr%20%3d%20new%20XMLHttpRequest()%3bxhr.open('GET'%2c%20'http%3a%2f%2f138.68.164.196%3a31813%2fadmin.php%3freveal_flag%3d1'%2c%20true)%3bxhr.withCredentials%20%3d%20true%3bxhr.send()%3b%3c%2fscript%3e&language=de"



and after a few seconds, we can see in the url "http://138.68.164.196:31813/admin.php?reveal_flag=1"

The fucking first flag HTB{38eb00cfc8f39eedb3d4fbe4e56512c5}

The fucking second flag HTB{6f4c51837d8148cb8dc66beb14003706}
