function t() {}

function e(t) {
    return t()
}

function n() {
    return Object.create(null)
}

function o(t) {
    t.forEach(e)
}

function c(t) {
    return "function" == typeof t
}

function r(t, e) {
    return t != t ? e == e : t !== e || t && "object" == typeof t || "function" == typeof t
}
let l, a = !1;

function i(t, e, n, o) {
    for (; t < e;) {
        const c = t + (e - t >> 1);
        n(c) <= o ? t = c + 1 : e = c
    }
    return t
}

function s(t, e) {
    a ? (! function (t) {
        if (t.hydrate_init) return;
        t.hydrate_init = !0;
        const e = t.childNodes,
            n = new Int32Array(e.length + 1),
            o = new Int32Array(e.length);
        n[0] = -1;
        let c = 0;
        for (let t = 0; t < e.length; t++) {
            const r = i(1, c + 1, (t => e[n[t]].claim_order), e[t].claim_order) - 1;
            o[t] = n[r] + 1;
            const l = r + 1;
            n[l] = t, c = Math.max(l, c)
        }
        const r = [],
            l = [];
        let a = e.length - 1;
        for (let t = n[c] + 1; 0 != t; t = o[t - 1]) {
            for (r.push(e[t - 1]); a >= t; a--) l.push(e[a]);
            a--
        }
        for (; a >= 0; a--) l.push(e[a]);
        r.reverse(), l.sort(((t, e) => t.claim_order - e.claim_order));
        for (let e = 0, n = 0; e < l.length; e++) {
            for (; n < r.length && l[e].claim_order >= r[n].claim_order;) n++;
            const o = n < r.length ? r[n] : null;
            t.insertBefore(l[e], o)
        }
    }(t), (void 0 === t.actual_end_child || null !== t.actual_end_child && t.actual_end_child.parentElement !== t) && (t.actual_end_child = t.firstChild), e !== t.actual_end_child ? t.insertBefore(e, t.actual_end_child) : t.actual_end_child = e.nextSibling) : e.parentNode !== t && t.appendChild(e)
}

function u(t, e, n) {
    a && !n ? s(t, e) : (e.parentNode !== t || n && e.nextSibling !== n) && t.insertBefore(e, n || null)
}

function f(t) {
    t.parentNode.removeChild(t)
}

function d(t) {
    return document.createElement(t)
}

function h(t) {
    return document.createTextNode(t)
}

function p() {
    return h(" ")
}

function m(t, e, n, o) {
    return t.addEventListener(e, n, o), () => t.removeEventListener(e, n, o)
}

function _(t) {
    return function (e) {
        return e.preventDefault(), t.call(this, e)
    }
}

function g(t, e, n) {
    null == n ? t.removeAttribute(e) : t.getAttribute(e) !== n && t.setAttribute(e, n)
}

function b(t, e) {
    e = "" + e, t.wholeText !== e && (t.data = e)
}

function v(t, e) {
    t.value = null == e ? "" : e
}

function y(t, e) {
    for (let n = 0; n < t.options.length; n += 1) {
        const o = t.options[n];
        if (o.__value === e) return void(o.selected = !0)
    }
}

function $(t) {
    l = t
}

function x(t) {
    (function () {
        if (!l) throw new Error("Function called outside component initialization");
        return l
    })().$$.on_mount.push(t)
}
const w = [],
    C = [],
    k = [],
    A = [],
    E = Promise.resolve();
let N = !1;

function S(t) {
    k.push(t)
}
let T = !1;
const M = new Set;

function P() {
    if (!T) {
        T = !0;
        do {
            for (let t = 0; t < w.length; t += 1) {
                const e = w[t];
                $(e), j(e.$$)
            }
            for ($(null), w.length = 0; C.length;) C.pop()();
            for (let t = 0; t < k.length; t += 1) {
                const e = k[t];
                M.has(e) || (M.add(e), e())
            }
            k.length = 0
        } while (w.length);
        for (; A.length;) A.pop()();
        N = !1, T = !1, M.clear()
    }
}

function j(t) {
    if (null !== t.fragment) {
        t.update(), o(t.before_update);
        const e = t.dirty;
        t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(S)
    }
}
const I = new Set;

function L(t, e) {
    -1 === t.$$.dirty[0] && (w.push(t), N || (N = !0, E.then(P)), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31
}

function O(r, i, s, u, d, h, p = [-1]) {
    const m = l;
    $(r);
    const _ = r.$$ = {
        fragment: null,
        ctx: null,
        props: h,
        update: t,
        not_equal: d,
        bound: n(),
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(m ? m.$$.context : i.context || []),
        callbacks: n(),
        dirty: p,
        skip_bound: !1
    };
    let g = !1;
    if (_.ctx = s ? s(r, i.props || {}, ((t, e, ...n) => {
            const o = n.length ? n[0] : e;
            return _.ctx && d(_.ctx[t], _.ctx[t] = o) && (!_.skip_bound && _.bound[t] && _.bound[t](o), g && L(r, t)), e
        })) : [], _.update(), g = !0, o(_.before_update), _.fragment = !!u && u(_.ctx), i.target) {
        if (i.hydrate) {
            a = !0;
            const t = function (t) {
                return Array.from(t.childNodes)
            }(i.target);
            _.fragment && _.fragment.l(t), t.forEach(f)
        } else _.fragment && _.fragment.c();
        i.intro && ((b = r.$$.fragment) && b.i && (I.delete(b), b.i(v))),
            function (t, n, r, l) {
                const {
                    fragment: a,
                    on_mount: i,
                    on_destroy: s,
                    after_update: u
                } = t.$$;
                a && a.m(n, r), l || S((() => {
                    const n = i.map(e).filter(c);
                    s ? s.push(...n) : o(n), t.$$.on_mount = []
                })), u.forEach(S)
            }(r, i.target, i.anchor, i.customElement), a = !1, P()
    }
    var b, v;
    $(m)
}

function B(t, e, n) {
    const o = t.slice();
    return o[6] = e[n].name, o[7] = e[n].species, o[8] = e[n].characteristics, o[10] = n, o
}

function H(t) {
    let e, n, o, c, r, l, a, i, v, y, $, x, w, C, k, A = t[6] + "",
        E = t[7].charAt(0).toUpperCase() + t[7].slice(1) + "",
        N = t[8] + "";
    return {
        c() {
            e = d("tr"), n = d("td"), o = h(A), c = p(), r = d("td"), l = h(E), a = p(), i = d("td"), v = h(N), y = p(), $ = d("td"), x = d("button"), x.innerHTML = '<i class="fas fa-trash"></i>', w = p(), g(x, "class", "btn btn-outline-secondary"), g(e, "id", t[10])
        },
        m(f, d) {
            u(f, e, d), s(e, n), s(n, o), s(e, c), s(e, r), s(r, l), s(e, a), s(e, i), s(i, v), s(e, y), s(e, $), s($, x), s(e, w), C || (k = m(x, "click", _(t[3])), C = !0)
        },
        p(t, e) {
            1 & e && A !== (A = t[6] + "") && b(o, A), 1 & e && E !== (E = t[7].charAt(0).toUpperCase() + t[7].slice(1) + "") && b(l, E), 1 & e && N !== (N = t[8] + "") && b(v, N)
        },
        d(t) {
            t && f(e), C = !1, k()
        }
    }
}

function W(e) {
    let n, c, r, l, a, i, h, b, $, x, w, C, k, A, E, N, T, M, P, j, I, L, O, W, q, D, G, U, z, F, J, K, R, Q, V = e[0],
        X = [];
    for (let t = 0; t < V.length; t += 1) X[t] = H(B(e, V, t));
    return {
        c() {
            n = d("main"), c = d("div"), c.innerHTML = '<h1 align="center">Pet Inventory</h1> \n\n    <p align="center">Welcome to my pet inventory. This is where I keep a list of my pets.</p> \n    <p align="center">I mean, come one, who doesn&#39;t like animals, right?</p>', r = p(), l = d("div"), a = d("h2"), a.textContent = "My Pets", i = p(), h = d("table"), b = d("thead"), b.innerHTML = '<tr><th scope="col">Name</th> \n          <th scope="col">Species</th> \n          <th scope="col">Characteristics</th> \n          <th scope="col"></th></tr>', $ = p(), x = d("tbody");
            for (let t = 0; t < X.length; t += 1) X[t].c();
            w = p(), C = d("div"), k = d("h2"), k.textContent = "Add a Pet", A = p(), E = d("form"), N = d("div"), T = d("label"), T.textContent = "Name the pet", M = p(), P = d("input"), j = p(), I = d("div"), L = d("label"), L.textContent = "Which species is it?", O = p(), W = d("select"), q = d("option"), q.textContent = "Cat", D = d("option"), D.textContent = "Dog", G = d("option"), G.textContent = "Gopher", U = d("option"), U.textContent = "Giraffe", z = d("option"), z.textContent = "Red Kite", F = d("option"), F.textContent = "Blue Whale", J = p(), K = d("button"), K.textContent = "Add Pet", g(c, "class", "row mb-5"), g(a, "align", "center"), g(h, "class", "table table-striped table-hover"), g(l, "class", "row mb-5"), g(k, "align", "center"), g(T, "for", "name"), g(T, "class", "form-label"), g(P, "type", "text"), g(P, "class", "form-control"), g(P, "name", "name"), g(P, "id", "name"), g(N, "class", "mb-3"), g(L, "for", "species"), g(L, "class", "form-label"), q.__value = "cat", q.value = q.__value, D.__value = "dog", D.value = D.__value, G.__value = "gopher", G.value = G.__value, U.__value = "giraffe", U.value = U.__value, z.__value = "redkite", z.value = z.__value, F.__value = "bluewhale", F.value = F.__value, g(W, "class", "form-select"), g(W, "name", "species"), g(W, "id", "species"), void 0 === e[1].species && S((() => e[5].call(W))), g(I, "class", "mb-3"), g(K, "class", "btn btn-outline-secondary"), g(K, "type", "submit"), g(C, "class", "row mb-5"), g(n, "class", "container")
        },
        m(t, o) {
            u(t, n, o), s(n, c), s(n, r), s(n, l), s(l, a), s(l, i), s(l, h), s(h, b), s(h, $), s(h, x);
            for (let t = 0; t < X.length; t += 1) X[t].m(x, null);
            s(n, w), s(n, C), s(C, k), s(C, A), s(C, E), s(E, N), s(N, T), s(N, M), s(N, P), v(P, e[1].name), s(E, j), s(E, I), s(I, L), s(I, O), s(I, W), s(W, q), s(W, D), s(W, G), s(W, U), s(W, z), s(W, F), y(W, e[1].species), s(E, J), s(E, K), R || (Q = [m(P, "input", e[4]), m(W, "change", e[5]), m(K, "click", _(e[2]))], R = !0)
        },
        p(t, [e]) {
            if (1 & e) {
                let n;
                for (V = t[0], n = 0; n < V.length; n += 1) {
                    const o = B(t, V, n);
                    X[n] ? X[n].p(o, e) : (X[n] = H(o), X[n].c(), X[n].m(x, null))
                }
                for (; n < X.length; n += 1) X[n].d(1);
                X.length = V.length
            }
            2 & e && P.value !== t[1].name && v(P, t[1].name), 2 & e && y(W, t[1].species)
        },
        i: t,
        o: t,
        d(t) {
            t && f(n),
                function (t, e) {
                    for (let n = 0; n < t.length; n += 1) t[n] && t[n].d(e)
                }(X, t), R = !1, o(Q)
        }
    }
}

function q(t, e, n) {
    let o = [],
        c = {
            name: "",
            species: "cat"
        };
    x((async () => {
        const t = await fetch("/api/pet");
        n(0, o = await t.json())
    }));
    return [o, c, async function () {
            await fetch("/api/pet", {
                method: "POST",
                body: JSON.stringify(c)
            }).then((async t => {
                if (200 == t.status) {
                    const t = await fetch("/api/pet");
                    n(0, o = await t.json()), n(1, c = {
                        name: ""
                    })
                }
            })).catch((t => alert(t)))
        }, () => alert("Not implemented, yet"),
        function () {
            c.name = this.value, n(1, c)
        },
        function () {
            c.species = function (t) {
                const e = t.querySelector(":checked") || t.options[0];
                return e && e.__value
            }(this), n(1, c)
        }]
}
const D = new class extends class {
    $destroy() {
        ! function (t, e) {
            const n = t.$$;
            null !== n.fragment && (o(n.on_destroy), n.fragment && n.fragment.d(e), n.on_destroy = n.fragment = null, n.ctx = [])
        }(this, 1), this.$destroy = t
    }
    $on(t, e) {
        const n = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
        return n.push(e), () => {
            const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
        }
    }
    $set(t) {
        var e;
        this.$$set && (e = t, 0 !== Object.keys(e).length) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1)
    }
} {
    constructor(t) {
        super(), O(this, t, q, W, r, {})
    }
}({
    target: document.body
});
export default D;
