#!/usr/bin/env python
import asyncio
import logging
import random
import grpc
from grpc_reflection.v1alpha import reflection
import app_pb2
import app_pb2_grpc
import sqlite3
import middle

con = sqlite3.connect("/opt/app/sqlite.db")
cur = con.cursor()


class Login(app_pb2_grpc.SimpleAppServicer):
    async def RegisterUser(self, request, context):
        username = request.username
        password = request.password
        if len(username) < 4 or len(password) < 4:
            return app_pb2.RegisterUserResponse(message="username or password must be greater than 4")
        result = cur.execute('SELECT EXISTS(SELECT 1 FROM accounts WHERE username = ?)', (username, )).fetchone()[0]

        if result == 0:
            cur.execute('INSERT INTO accounts values(?, ?)', (username, password))
            con.commit()
            return app_pb2.RegisterUserResponse(message=f'Account created for user {username}!')
        else:
            return app_pb2.RegisterUserResponse(message='User Already Exists!!')

    async def LoginUser(self, request, context):
        username = request.username
        password = request.password
        result = cur.execute('SELECT EXISTS(SELECT 1 FROM accounts WHERE username = ? and password = ? )', (username, password)).fetchone()[0]
        if result == 1:
            # setting response header
            context.set_trailing_metadata((
                ('token', f'{middle.token(username)}'),
            ))
            rand_number = random.randint(1,900)
            #should match any primary or unique constraint 
            cur.execute(f'''INSERT INTO messages VALUES({rand_number}, ? , "Will update soon.") ON CONFLICT (username)
                        DO  UPDATE SET id = "{rand_number}", username = ?, message = "Will update soon."                                            
                        ''', (username, username))
            con.commit()
            return app_pb2.LoginUserResponse(message=f'Your id is {rand_number}.')
        else:
            return app_pb2.LoginUserResponse(message="Login unsuccessful")

    async def getInfo(self, request, context):
        headers = dict(context.invocation_metadata())
        token = headers.get('token')
        user_id = middle.authorization(token)
        if user_id is True:
            try:
                result = cur.execute(f'SELECT message from messages where id = {request.id}').fetchone()[0]
                return app_pb2.getInfoResponse(message=f"{result}")
            except sqlite3.Error as er:
                return app_pb2.getInfoResponse(message=er)
        return app_pb2.getInfoResponse(message="Authorization Error.Missing 'token' header")

async def serve() -> None:
    server = grpc.aio.server()
    app_pb2_grpc.add_SimpleAppServicer_to_server(Login(), server)
    SERVICE_NAMES = (
        app_pb2.DESCRIPTOR.services_by_name['SimpleApp'].full_name,
        reflection.SERVICE_NAME,
    )
    reflection.enable_server_reflection(SERVICE_NAMES, server)
    server.add_insecure_port('0.0.0.0:50051')
    await server.start()
    await server.wait_for_termination()


if __name__ == '__main__':
    logging.basicConfig()
    asyncio.run(serve())
